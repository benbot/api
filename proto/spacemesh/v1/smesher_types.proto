syntax = "proto3";
package spacemesh.v1;
option go_package = "github.com/spacemeshos/api/release/go/spacemesh/v1";
import "spacemesh/v1/types.proto";
import "google/rpc/status.proto";

// Basic user provided smeshing data
message SmeshingData {
    string path = 1; // User provided volume path to create the proof of space data files at
    uint64 data_size = 2; // Requested post data size in units
    bool   throttle = 3; // Throttle down setup phase computations while user is interactive on system
    uint32 provider_id = 4; // A PostProvider id to be used to create the proof of space data
    AccountId coinbase = 5; // User requested smeshing rewards account
}

// Smeshing status
message SmeshingStatus {
    bool is_smeshing = 1; // true if post data was created and node is set to smesh
    enum FilesStatus { // proof of space data files status
        FILES_STATUS_UNSPECIFIED = 0;
        FILES_STATUS_NOT_FOUND = 1; // Some or all of expected data files do not exist
        FILES_STATUS_PARTIAL = 2; // Some files exist and setup can be continued (and is in progress)
        FILES_STATUS_COMPLETE = 3; // Expected data files are available and verified
    }
    FilesStatus files_status = 2;
    bool setup_in_progress = 3; // True if post setup process is currently in progress (writing data)
    uint64 bytes_written = 4; // Bytes written to the data files (actual total files sizes)
    string error_message = 5; // Last init process error message
    enum ErrorType {
        ERROR_TYPE_UNSPECIFIED = 0;
        ERROR_TYPE_READ_ERROR = 1; // Failure to read from a data file
        ERROR_TYPE_WRITE_ERROR = 2; // Failure to write to a data file
    }
    ErrorType error_type = 6;
    AccountId smesher_id = 7;
    AccountId coinbase_address = 8;
}

message SmeshingStatusResponse {
    SmeshingStatus status = 1;
}

message StartSmeshingRequest {
    SmeshingData smeshing_data = 1;
}

message StartSmeshingResponse {
    google.rpc.Status status = 1;
}

message StopSmeshingRequest {
    // request node to stop participating in protocol. If false, node will not submit new activations to the network
    // but will continue to participate in protocol and may get additional rewards
    bool stop_protocol_participation = 1;
}

message StopSmeshingResponse {
    google.rpc.Status status = 1;
}

message SetCoinbaseRequest {
    AccountId id = 1;
}

message SetCoinbaseResponse {
    google.rpc.Status status = 1;
}

message SmesherIDResponse {
    AccountId account_id = 1;
}

message CoinbaseResponse {
    AccountId account_id = 1;
}

message PostComputeProvider {
    uint32 id = 1; // 0, 1, 2...
    string model = 2; // e.g. Nvidia GTX 2700
    ComputeApiClass compute_api = 3; // A provided compute api
    uint64 performance = 4; // Estimated performance in hashes per second
}

message PostComputeProvidersResponse {
    repeated PostComputeProvider post_compute_provider = 1;
}

// Compute API class
enum ComputeApiClass {
    COMPUTE_API_CLASS_UNSPECIFIED = 0;
    COMPUTE_API_CLASS_CPU = 1; // useful for testing on systems without a cuda or vulkan GPU
    COMPUTE_API_CLASS_CUDA = 2;
    COMPUTE_API_CLASS_VULKAN = 3;
}

message EstimatedRewardsRequest {}

// Estimated rewards for the next epoch. Note that this is a global value that will be the
// same for all smeshers, and is based on the default minimum commitment size and fixed
// epoch length, both of which are network params.
message EstimatedRewardsResponse {
    // The amount of the total estimated reward in the next upcoming epoch
    Amount amount = 1;
    // The commitment size that this estimated reward corresponds to (part of global config)
    uint64 data_size = 2;
}

message MinGasResponse {
    SimpleInt mingas = 1;
}

message SetMinGasRequest {
    SimpleInt mingas = 1;
}

message SetMinGasResponse {
    google.rpc.Status status = 1;
}

message SmeshingStatusStreamResponse {
    SmeshingStatus status = 1;
}